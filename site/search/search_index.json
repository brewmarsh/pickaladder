{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Pickaladder","title":"Home"},{"location":"#welcome-to-pickaladder","text":"","title":"Welcome to Pickaladder"},{"location":"API/","text":"pickaladder API Documentation This document describes the API for the pickaladder application. 1. Authentication The API uses a session-based authentication mechanism. After a user logs in, a user_id is stored in the session. This user_id is used to authenticate subsequent requests. 2. Endpoints The application is divided into blueprints, and the endpoints are prefixed with the blueprint name. 2.1. Auth Blueprint ( /auth ) POST /auth/register Registers a new user. Request Body: username , password , email , name , dupr_rating Response: Redirects to the dashboard on success. POST /auth/login Logs in a user. Request Body: username , password Response: Redirects to the dashboard on success. GET /auth/logout Logs out a user. Response: Redirects to the index page. GET /auth/verify_email/<email> Verifies a user's email address. Response: Redirects to the login page. 2.2. User Blueprint ( / ) GET /dashboard Displays the user's dashboard. GET /users Displays a list of all users. GET /users/<user_id> Displays a user's profile. GET /friends Displays the user's friends and friend requests. POST /user/add_friend/<friend_id> Sends a friend request to another user. This endpoint is intended to be used with AJAX. Response: A JSON object with a success boolean and a message string. 2.3. Match Blueprint ( /match ) GET /match/leaderboard Returns the top 10 players by average score. Response: A rendered HTML page with the leaderboard. GET /match/<uuid:match_id> Displays the details of a match. 2.4. Admin Blueprint ( /admin ) GET /admin/generate_matches Generates 10 random matches between friends. Response: Redirects to the admin page. GET /admin/friend_graph_data Returns the data for the friend graph. Response: A JSON object with nodes and edges . 3. Data Models 3.1. User id (UUID) username (string) password (string) email (string) name (string) dupr_rating (float) is_admin (boolean) profile_picture (bytea) profile_picture_thumbnail (bytea) dark_mode (boolean) email_verified (boolean) 3.2. Match id (UUID) player1_id (UUID) player2_id (UUID) player1_score (integer) player2_score (integer) match_date (date) 3.3. Friend user_id (UUID) friend_id (UUID) status (string)","title":"pickaladder API Documentation"},{"location":"API/#pickaladder-api-documentation","text":"This document describes the API for the pickaladder application.","title":"pickaladder API Documentation"},{"location":"API/#1-authentication","text":"The API uses a session-based authentication mechanism. After a user logs in, a user_id is stored in the session. This user_id is used to authenticate subsequent requests.","title":"1. Authentication"},{"location":"API/#2-endpoints","text":"The application is divided into blueprints, and the endpoints are prefixed with the blueprint name.","title":"2. Endpoints"},{"location":"API/#21-auth-blueprint-auth","text":"","title":"2.1. Auth Blueprint (/auth)"},{"location":"API/#post-authregister","text":"Registers a new user. Request Body: username , password , email , name , dupr_rating Response: Redirects to the dashboard on success.","title":"POST /auth/register"},{"location":"API/#post-authlogin","text":"Logs in a user. Request Body: username , password Response: Redirects to the dashboard on success.","title":"POST /auth/login"},{"location":"API/#get-authlogout","text":"Logs out a user. Response: Redirects to the index page.","title":"GET /auth/logout"},{"location":"API/#get-authverify_emailemail","text":"Verifies a user's email address. Response: Redirects to the login page.","title":"GET /auth/verify_email/&lt;email&gt;"},{"location":"API/#22-user-blueprint","text":"","title":"2.2. User Blueprint (/)"},{"location":"API/#get-dashboard","text":"Displays the user's dashboard.","title":"GET /dashboard"},{"location":"API/#get-users","text":"Displays a list of all users.","title":"GET /users"},{"location":"API/#get-usersuser_id","text":"Displays a user's profile.","title":"GET /users/&lt;user_id&gt;"},{"location":"API/#get-friends","text":"Displays the user's friends and friend requests.","title":"GET /friends"},{"location":"API/#post-useradd_friendfriend_id","text":"Sends a friend request to another user. This endpoint is intended to be used with AJAX. Response: A JSON object with a success boolean and a message string.","title":"POST /user/add_friend/&lt;friend_id&gt;"},{"location":"API/#23-match-blueprint-match","text":"","title":"2.3. Match Blueprint (/match)"},{"location":"API/#get-matchleaderboard","text":"Returns the top 10 players by average score. Response: A rendered HTML page with the leaderboard.","title":"GET /match/leaderboard"},{"location":"API/#get-matchuuidmatch_id","text":"Displays the details of a match.","title":"GET /match/&lt;uuid:match_id&gt;"},{"location":"API/#24-admin-blueprint-admin","text":"","title":"2.4. Admin Blueprint (/admin)"},{"location":"API/#get-admingenerate_matches","text":"Generates 10 random matches between friends. Response: Redirects to the admin page.","title":"GET /admin/generate_matches"},{"location":"API/#get-adminfriend_graph_data","text":"Returns the data for the friend graph. Response: A JSON object with nodes and edges .","title":"GET /admin/friend_graph_data"},{"location":"API/#3-data-models","text":"","title":"3. Data Models"},{"location":"API/#31-user","text":"id (UUID) username (string) password (string) email (string) name (string) dupr_rating (float) is_admin (boolean) profile_picture (bytea) profile_picture_thumbnail (bytea) dark_mode (boolean) email_verified (boolean)","title":"3.1. User"},{"location":"API/#32-match","text":"id (UUID) player1_id (UUID) player2_id (UUID) player1_score (integer) player2_score (integer) match_date (date)","title":"3.2. Match"},{"location":"API/#33-friend","text":"user_id (UUID) friend_id (UUID) status (string)","title":"3.3. Friend"},{"location":"CONFIGURATION/","text":"Application Configuration This document outlines the steps required to configure the Pick-a-Ladder application to run with your own Firebase project. Firebase Credentials Setup To connect the application to your Firebase project, you need to provide it with a service account credentials file and your project ID. There are two main scenarios for running the app: 1. For Local Development (using Docker) You will use your downloaded Firebase service account key (a JSON file). Get Your Credentials File: Go to your project in the Firebase Console . Click the gear icon next to \"Project Overview\" and go to Project settings . Go to the Service accounts tab. Click the \"Generate new private key\" button. This will download a JSON file containing your credentials. Place the File in the Project: Rename the downloaded file to firebase-credentials.json . Move this file into the root directory of the project (the same folder where docker-compose.yml is located). The .gitignore file is already set up to ignore this file, so it won't be committed to your repository. Set Your Project ID: Open the docker-compose.yml file. In the environment section for the web service, find the line that says FIREBASE_PROJECT_ID=your-firebase-project-id . Replace your-firebase-project-id with your actual Firebase Project ID. Now, when you run docker compose up , the application will have the necessary credentials to connect to your Firebase project. 2. For Production Deployment (using GitHub Actions) For deployment, you should use GitHub Secrets to store your credentials securely. Go to Your Repository Settings on GitHub: Navigate to your repository's page on GitHub. Click on Settings > Secrets and variables > Actions . Create the Credentials Secret: Click the \"New repository secret\" button. For the Name , enter FIREBASE_CREDENTIALS_JSON . For the Value , open the firebase-credentials.json file you downloaded earlier, copy its entire content, and paste it into this field. Create the Project ID Secret: Click \"New repository secret\" again. For the Name , enter FIREBASE_PROJECT_ID . For the Value , enter your Firebase Project ID. Once these secrets are saved, the deployment workflow defined in .github/workflows/deploy.yml will automatically use them to configure your application when it deploys.","title":"Application Configuration"},{"location":"CONFIGURATION/#application-configuration","text":"This document outlines the steps required to configure the Pick-a-Ladder application to run with your own Firebase project.","title":"Application Configuration"},{"location":"CONFIGURATION/#firebase-credentials-setup","text":"To connect the application to your Firebase project, you need to provide it with a service account credentials file and your project ID. There are two main scenarios for running the app:","title":"Firebase Credentials Setup"},{"location":"CONFIGURATION/#1-for-local-development-using-docker","text":"You will use your downloaded Firebase service account key (a JSON file). Get Your Credentials File: Go to your project in the Firebase Console . Click the gear icon next to \"Project Overview\" and go to Project settings . Go to the Service accounts tab. Click the \"Generate new private key\" button. This will download a JSON file containing your credentials. Place the File in the Project: Rename the downloaded file to firebase-credentials.json . Move this file into the root directory of the project (the same folder where docker-compose.yml is located). The .gitignore file is already set up to ignore this file, so it won't be committed to your repository. Set Your Project ID: Open the docker-compose.yml file. In the environment section for the web service, find the line that says FIREBASE_PROJECT_ID=your-firebase-project-id . Replace your-firebase-project-id with your actual Firebase Project ID. Now, when you run docker compose up , the application will have the necessary credentials to connect to your Firebase project.","title":"1. For Local Development (using Docker)"},{"location":"CONFIGURATION/#2-for-production-deployment-using-github-actions","text":"For deployment, you should use GitHub Secrets to store your credentials securely. Go to Your Repository Settings on GitHub: Navigate to your repository's page on GitHub. Click on Settings > Secrets and variables > Actions . Create the Credentials Secret: Click the \"New repository secret\" button. For the Name , enter FIREBASE_CREDENTIALS_JSON . For the Value , open the firebase-credentials.json file you downloaded earlier, copy its entire content, and paste it into this field. Create the Project ID Secret: Click \"New repository secret\" again. For the Name , enter FIREBASE_PROJECT_ID . For the Value , enter your Firebase Project ID. Once these secrets are saved, the deployment workflow defined in .github/workflows/deploy.yml will automatically use them to configure your application when it deploys.","title":"2. For Production Deployment (using GitHub Actions)"},{"location":"DESIGN/","text":"pickaladder Design Document This document outlines the design of the pickaladder application. 1. Introduction The pickaladder application is a web-based application that allows users to create and manage pickleball ladders. 2. System Architecture The application is a monolithic web application built with Flask and PostgreSQL. It is containerized with Docker and deployed with docker-compose. 2.1. Application Architecture The Flask application is organized using a blueprint-based architecture. The application is divided into the following blueprints: auth : Handles user authentication, including registration, login, logout, and password management. user : Handles user-facing features, such as the user dashboard, user profiles, and friend management. admin : Handles administrative features, such as user management, database management, and data generation. match : Handles match-related features, such as creating and viewing matches, and the leaderboard. 2.2. Build Process The application is built using a multi-stage Docker build. * Stage 1 (builder) : This stage uses a node base image to build the React frontend. It copies the frontend code, installs dependencies, and runs the build script. * Stage 2 (final) : This stage uses a python base image. It copies the Python application code, installs the Python dependencies, and then copies the built frontend assets from the builder stage. This approach results in a small, optimized production image that does not contain any of the build-time dependencies. 3. Database 3.1. Database Schema The database schema is defined in the init.sql file and is versioned with migration scripts in the migrations directory. The schema consists of the following tables: users : Stores user information. friends : Stores friendship information. matches : Stores match information. migrations : Stores information about applied migrations. The users table has the following columns: id : A UUID that uniquely identifies each user. username : The user's username. password : The user's hashed password. email : The user's email address. name : The user's name. dupr_rating : The user's DUPR rating. is_admin : A boolean that indicates whether the user is an administrator. profile_picture : The user's profile picture, stored as a blob. profile_picture_thumbnail : A thumbnail of the user's profile picture, stored as a blob. dark_mode : A boolean that indicates whether the user has enabled dark mode. email_verified : A boolean that indicates whether the user has verified their email address. 3.2. Database Connection Management The application uses a psycopg2 connection pool to manage database connections. The connection pool is initialized when the application starts, and connections are managed by the Flask application context. 4. Application Logic The application logic is implemented in the pickaladder package. The application is divided into blueprints, each with its own routes.py file that contains the routes for that part of the application. The application uses an application factory pattern ( create_app ) to create and configure the Flask application instance. 5. User Interface The user interface is implemented with HTML, CSS, and JavaScript, following a modern, clean, and responsive design aesthetic inspired by Google's Material Design. The application uses a custom stylesheet for all its styling, ensuring a lightweight and consistent look and feel across all pages. 5.1. Design Philosophy The UI design is guided by the following principles: Clarity: The interface is designed to be intuitive and easy to navigate. Efficiency: Users can accomplish tasks with a minimum number of actions. Consistency: UI elements and layouts are consistent throughout the application. Simplicity: The design is clean and uncluttered, with a focus on a great user experience. 5.2. Styling All styling is handled by a custom CSS stylesheet located at pickaladder/static/style.css . The stylesheet uses CSS variables for colors, fonts, and other properties to ensure consistency and maintainability. The application does not use any external CSS frameworks like Bootstrap. 5.3. Templates The application uses the Jinja2 templating engine. All pages extend a base layout template ( layout.html ) to ensure a consistent structure. The templates are located in the pickaladder/templates directory. 5.4. Key UI Features Match View: The match view page provides a detailed look at a single match. It emphasizes the winner's profile picture with a border and a box-shadow, and fades the loser's icon to create a clear visual distinction. It also displays each player's win/loss record under their username. The user's icon and username are clickable links to their profile page. User Profile: The user profile page includes a match history section. Each match in the history is a clickable link to the match details page, and the winning score is displayed in bold.","title":"pickaladder Design Document"},{"location":"DESIGN/#pickaladder-design-document","text":"This document outlines the design of the pickaladder application.","title":"pickaladder Design Document"},{"location":"DESIGN/#1-introduction","text":"The pickaladder application is a web-based application that allows users to create and manage pickleball ladders.","title":"1. Introduction"},{"location":"DESIGN/#2-system-architecture","text":"The application is a monolithic web application built with Flask and PostgreSQL. It is containerized with Docker and deployed with docker-compose.","title":"2. System Architecture"},{"location":"DESIGN/#21-application-architecture","text":"The Flask application is organized using a blueprint-based architecture. The application is divided into the following blueprints: auth : Handles user authentication, including registration, login, logout, and password management. user : Handles user-facing features, such as the user dashboard, user profiles, and friend management. admin : Handles administrative features, such as user management, database management, and data generation. match : Handles match-related features, such as creating and viewing matches, and the leaderboard.","title":"2.1. Application Architecture"},{"location":"DESIGN/#22-build-process","text":"The application is built using a multi-stage Docker build. * Stage 1 (builder) : This stage uses a node base image to build the React frontend. It copies the frontend code, installs dependencies, and runs the build script. * Stage 2 (final) : This stage uses a python base image. It copies the Python application code, installs the Python dependencies, and then copies the built frontend assets from the builder stage. This approach results in a small, optimized production image that does not contain any of the build-time dependencies.","title":"2.2. Build Process"},{"location":"DESIGN/#3-database","text":"","title":"3. Database"},{"location":"DESIGN/#31-database-schema","text":"The database schema is defined in the init.sql file and is versioned with migration scripts in the migrations directory. The schema consists of the following tables: users : Stores user information. friends : Stores friendship information. matches : Stores match information. migrations : Stores information about applied migrations. The users table has the following columns: id : A UUID that uniquely identifies each user. username : The user's username. password : The user's hashed password. email : The user's email address. name : The user's name. dupr_rating : The user's DUPR rating. is_admin : A boolean that indicates whether the user is an administrator. profile_picture : The user's profile picture, stored as a blob. profile_picture_thumbnail : A thumbnail of the user's profile picture, stored as a blob. dark_mode : A boolean that indicates whether the user has enabled dark mode. email_verified : A boolean that indicates whether the user has verified their email address.","title":"3.1. Database Schema"},{"location":"DESIGN/#32-database-connection-management","text":"The application uses a psycopg2 connection pool to manage database connections. The connection pool is initialized when the application starts, and connections are managed by the Flask application context.","title":"3.2. Database Connection Management"},{"location":"DESIGN/#4-application-logic","text":"The application logic is implemented in the pickaladder package. The application is divided into blueprints, each with its own routes.py file that contains the routes for that part of the application. The application uses an application factory pattern ( create_app ) to create and configure the Flask application instance.","title":"4. Application Logic"},{"location":"DESIGN/#5-user-interface","text":"The user interface is implemented with HTML, CSS, and JavaScript, following a modern, clean, and responsive design aesthetic inspired by Google's Material Design. The application uses a custom stylesheet for all its styling, ensuring a lightweight and consistent look and feel across all pages.","title":"5. User Interface"},{"location":"DESIGN/#51-design-philosophy","text":"The UI design is guided by the following principles: Clarity: The interface is designed to be intuitive and easy to navigate. Efficiency: Users can accomplish tasks with a minimum number of actions. Consistency: UI elements and layouts are consistent throughout the application. Simplicity: The design is clean and uncluttered, with a focus on a great user experience.","title":"5.1. Design Philosophy"},{"location":"DESIGN/#52-styling","text":"All styling is handled by a custom CSS stylesheet located at pickaladder/static/style.css . The stylesheet uses CSS variables for colors, fonts, and other properties to ensure consistency and maintainability. The application does not use any external CSS frameworks like Bootstrap.","title":"5.2. Styling"},{"location":"DESIGN/#53-templates","text":"The application uses the Jinja2 templating engine. All pages extend a base layout template ( layout.html ) to ensure a consistent structure. The templates are located in the pickaladder/templates directory.","title":"5.3. Templates"},{"location":"DESIGN/#54-key-ui-features","text":"Match View: The match view page provides a detailed look at a single match. It emphasizes the winner's profile picture with a border and a box-shadow, and fades the loser's icon to create a clear visual distinction. It also displays each player's win/loss record under their username. The user's icon and username are clickable links to their profile page. User Profile: The user profile page includes a match history section. Each match in the history is a clickable link to the match details page, and the winning score is displayed in bold.","title":"5.4. Key UI Features"},{"location":"FIREBASE_MIGRATION/","text":"Requirements for Migrating Pick-a-Ladder to Firebase 1. Overview This document outlines the requirements for refactoring the Pick-a-Ladder web application from its current Flask and PostgreSQL architecture to a serverless backend using Google Firebase services. The primary motivation for this migration is to resolve persistent and complex server environment issues related to Docker networking, container orchestration, and database connectivity. The goal is to create a more reliable, scalable, and easier-to-manage backend while retaining all existing application functionality. The migration will involve a complete rewrite of the data access, authentication, and file storage layers. 2. Core Firebase Services to be Used The new architecture will be built on the following Firebase services: Firebase Authentication: To handle all user identity and authentication tasks (sign-up, login, password reset, email verification). Cloud Firestore: A NoSQL document database that will replace PostgreSQL as the primary data store for all application data (users, matches, groups, etc.). Firebase Storage: To store all user-generated content, specifically user profile pictures. 3. Data Model Migration (PostgreSQL to Firestore) The existing SQL data models must be migrated to a NoSQL document-based structure in Firestore. The following collections and data structures are proposed. Note that Firestore document IDs will be used as the primary identifier for all resources. 3.1. users Collection A root-level collection where each document represents a single user. The document ID should be the uid generated by Firebase Authentication. Document ID: auth.uid Fields: username : (String) - Must remain unique. email : (String) - The email used for authentication. name : (String) - The user's full name. duprRating : (Number) - The user's DUPR rating. isAdmin : (Boolean) - true if the user has administrative privileges. profilePictureUrl : (String) - URL to the full-size profile picture in Firebase Storage. profilePictureThumbnailUrl : (String) - URL to the thumbnail-size profile picture. darkMode : (Boolean) - User's preference for dark mode. createdAt : (Timestamp) - Server-side timestamp of account creation. 3.2. matches Collection A root-level collection for all matches. Document ID: Auto-generated by Firestore. Fields: player1Ref : (DocumentReference) - A reference to the user document of player 1. player2Ref : (DocumentReference) - A reference to the user document of player 2. player1Score : (Number) player2Score : (Number) matchDate : (Timestamp) 3.3. groups Collection A root-level collection for user-created groups. Document ID: Auto-generated by Firestore. Fields: name : (String) description : (String) ownerRef : (DocumentReference) - A reference to the user document of the group's owner. members : (Array of DocumentReference) - An array containing references to all user documents that are members of the group. 3.4. Friends Relationship The many-to-many friends relationship will be modeled using a sub-collection on each user document. This is a robust way to handle this relationship in Firestore. For a user with ID userA , their friends will be stored in a sub-collection at: /users/userA/friends . Each document in the friends sub-collection represents a friendship. The document ID should be the uid of the friend. Document ID: friend.uid Fields: status : (String) - e.g., \"pending\", \"accepted\". createdAt : (Timestamp) - When the friend request was initiated. 3.5. settings Collection A root-level collection to store global application settings. Document ID: The key of the setting (e.g., \"enforceEmailVerification\"). Fields: value : (Varies) - The value of the setting (e.g., Boolean true ). 4. Authentication Refactoring The entire authentication system must be rebuilt using Firebase Authentication. Registration: The \"Register\" page will use the Firebase SDK to create a new user with an email and password. Upon successful creation, a corresponding user document must be created in the users collection in Firestore. Login/Logout: All login and logout functionality will be handled by the Firebase SDK. Session Management: Flask's session management will be replaced. The application will rely on the Firebase ID token, which should be sent from the client on each authenticated request and verified on the server-side by the Flask backend. Password Reset: The \"Forgot Password\" flow will use the built-in Firebase Authentication \"send password reset email\" functionality. Email Verification: The email verification flow will use the built-in Firebase Authentication functionality. The application must check the email_verified status from the user's Firebase token. Initial Admin User: The application must still handle the \"first run\" scenario. If there are no documents in the users collection with isAdmin: true , the application should redirect to the /install page to create the first administrative user. 5. File Storage Refactoring All user profile picture functionality must be migrated to Firebase Storage. Uploads: When a user uploads a profile picture, the file must be uploaded directly from the client (or via the server) to a private, user-specific path in Firebase Storage (e.g., /profile-pictures/{user_uid}/original.jpg ). Security Rules: Firebase Storage security rules must be implemented to ensure that users can only write to their own storage path. Thumbnail Generation: The current implementation generates thumbnails on the server. This should be replaced with a more scalable solution. Requirement: Implement a Firebase Cloud Function that triggers on file upload to Firebase Storage. This function will automatically generate a thumbnail (e.g., 100x100 pixels) and save it to a different path in the user's storage bucket. The URLs for both the original and the thumbnail must then be updated in the user's document in the users collection. 6. Application Logic Refactoring All application code that currently interacts with the PostgreSQL database via SQLAlchemy must be rewritten to use the Firebase Admin SDK for Python. A comprehensive code review must be performed to identify all instances of db.session usage. All routes in auth , admin , user , match , and group blueprints must be refactored. All forms in forms.py that rely on database queries for validation must be updated. All utility functions in utils.py that perform database operations must be rewritten. 7. Environment and Configuration Firebase Credentials: The Firebase Admin SDK requires service account credentials. These credentials (a JSON file) must not be committed to the repository. They should be stored securely as a GitHub secret and loaded into the production environment during the deployment workflow. Deployment Workflow: The .github/workflows/deploy.yml file must be updated. The db service and the postgres_data volume must be removed. The workflow will need a new step to securely load the Firebase service account key into the server environment for the application to use. 8. Corner Cases and Considerations Data Migration: The current user base is small or non-existent, so a complex data migration script from PostgreSQL to Firebase is not required at this stage. The new system will start fresh. Error Handling: All calls to Firebase services must be wrapped in appropriate try...except blocks to handle potential API errors gracefully (e.g., permission denied, document not found). Security Rules: This is a critical requirement. Write and test comprehensive security rules for both Firestore and Firebase Storage. The default should be to deny all access. Rules should be written to grant access only to authenticated users for their own data. Administrative access should also be handled via security rules where possible. Uniqueness Constraints: Firestore does not enforce unique field values (e.g., for username ). This must be handled by the application logic. When a user registers, the application must first query the users collection to ensure the chosen username is not already taken before creating the new user. This must be done in a transaction to avoid race conditions. 9. Definition of Done The migration will be considered complete when all of the following criteria are met: [ ] All PostgreSQL-related code ( SQLAlchemy , psycopg2-binary ) has been removed from the application. [ ] All user authentication flows (register, login, logout, password reset) are fully functional using Firebase Authentication. [ ] The initial admin user setup flow is working correctly. [ ] Users can upload and change their profile pictures, and thumbnails are generated and displayed correctly. [ ] All \"friends\" features (sending requests, accepting requests, viewing friends) are fully functional. [ ] All \"groups\" features (creating, editing, joining, viewing) are fully functional. [ ] All \"match\" features (creating matches, viewing leaderboard) are fully functional. [ ] All administrative functions are working correctly. [ ] The deployment workflow is updated and successfully deploys the new Firebase-backed application. [ ] Comprehensive security rules for Firestore and Firebase Storage are implemented and tested. [ ] The application is stable and the original 500 error is resolved.","title":"Requirements for Migrating Pick-a-Ladder to Firebase"},{"location":"FIREBASE_MIGRATION/#requirements-for-migrating-pick-a-ladder-to-firebase","text":"","title":"Requirements for Migrating Pick-a-Ladder to Firebase"},{"location":"FIREBASE_MIGRATION/#1-overview","text":"This document outlines the requirements for refactoring the Pick-a-Ladder web application from its current Flask and PostgreSQL architecture to a serverless backend using Google Firebase services. The primary motivation for this migration is to resolve persistent and complex server environment issues related to Docker networking, container orchestration, and database connectivity. The goal is to create a more reliable, scalable, and easier-to-manage backend while retaining all existing application functionality. The migration will involve a complete rewrite of the data access, authentication, and file storage layers.","title":"1. Overview"},{"location":"FIREBASE_MIGRATION/#2-core-firebase-services-to-be-used","text":"The new architecture will be built on the following Firebase services: Firebase Authentication: To handle all user identity and authentication tasks (sign-up, login, password reset, email verification). Cloud Firestore: A NoSQL document database that will replace PostgreSQL as the primary data store for all application data (users, matches, groups, etc.). Firebase Storage: To store all user-generated content, specifically user profile pictures.","title":"2. Core Firebase Services to be Used"},{"location":"FIREBASE_MIGRATION/#3-data-model-migration-postgresql-to-firestore","text":"The existing SQL data models must be migrated to a NoSQL document-based structure in Firestore. The following collections and data structures are proposed. Note that Firestore document IDs will be used as the primary identifier for all resources.","title":"3. Data Model Migration (PostgreSQL to Firestore)"},{"location":"FIREBASE_MIGRATION/#31-users-collection","text":"A root-level collection where each document represents a single user. The document ID should be the uid generated by Firebase Authentication. Document ID: auth.uid Fields: username : (String) - Must remain unique. email : (String) - The email used for authentication. name : (String) - The user's full name. duprRating : (Number) - The user's DUPR rating. isAdmin : (Boolean) - true if the user has administrative privileges. profilePictureUrl : (String) - URL to the full-size profile picture in Firebase Storage. profilePictureThumbnailUrl : (String) - URL to the thumbnail-size profile picture. darkMode : (Boolean) - User's preference for dark mode. createdAt : (Timestamp) - Server-side timestamp of account creation.","title":"3.1. users Collection"},{"location":"FIREBASE_MIGRATION/#32-matches-collection","text":"A root-level collection for all matches. Document ID: Auto-generated by Firestore. Fields: player1Ref : (DocumentReference) - A reference to the user document of player 1. player2Ref : (DocumentReference) - A reference to the user document of player 2. player1Score : (Number) player2Score : (Number) matchDate : (Timestamp)","title":"3.2. matches Collection"},{"location":"FIREBASE_MIGRATION/#33-groups-collection","text":"A root-level collection for user-created groups. Document ID: Auto-generated by Firestore. Fields: name : (String) description : (String) ownerRef : (DocumentReference) - A reference to the user document of the group's owner. members : (Array of DocumentReference) - An array containing references to all user documents that are members of the group.","title":"3.3. groups Collection"},{"location":"FIREBASE_MIGRATION/#34-friends-relationship","text":"The many-to-many friends relationship will be modeled using a sub-collection on each user document. This is a robust way to handle this relationship in Firestore. For a user with ID userA , their friends will be stored in a sub-collection at: /users/userA/friends . Each document in the friends sub-collection represents a friendship. The document ID should be the uid of the friend. Document ID: friend.uid Fields: status : (String) - e.g., \"pending\", \"accepted\". createdAt : (Timestamp) - When the friend request was initiated.","title":"3.4. Friends Relationship"},{"location":"FIREBASE_MIGRATION/#35-settings-collection","text":"A root-level collection to store global application settings. Document ID: The key of the setting (e.g., \"enforceEmailVerification\"). Fields: value : (Varies) - The value of the setting (e.g., Boolean true ).","title":"3.5. settings Collection"},{"location":"FIREBASE_MIGRATION/#4-authentication-refactoring","text":"The entire authentication system must be rebuilt using Firebase Authentication. Registration: The \"Register\" page will use the Firebase SDK to create a new user with an email and password. Upon successful creation, a corresponding user document must be created in the users collection in Firestore. Login/Logout: All login and logout functionality will be handled by the Firebase SDK. Session Management: Flask's session management will be replaced. The application will rely on the Firebase ID token, which should be sent from the client on each authenticated request and verified on the server-side by the Flask backend. Password Reset: The \"Forgot Password\" flow will use the built-in Firebase Authentication \"send password reset email\" functionality. Email Verification: The email verification flow will use the built-in Firebase Authentication functionality. The application must check the email_verified status from the user's Firebase token. Initial Admin User: The application must still handle the \"first run\" scenario. If there are no documents in the users collection with isAdmin: true , the application should redirect to the /install page to create the first administrative user.","title":"4. Authentication Refactoring"},{"location":"FIREBASE_MIGRATION/#5-file-storage-refactoring","text":"All user profile picture functionality must be migrated to Firebase Storage. Uploads: When a user uploads a profile picture, the file must be uploaded directly from the client (or via the server) to a private, user-specific path in Firebase Storage (e.g., /profile-pictures/{user_uid}/original.jpg ). Security Rules: Firebase Storage security rules must be implemented to ensure that users can only write to their own storage path. Thumbnail Generation: The current implementation generates thumbnails on the server. This should be replaced with a more scalable solution. Requirement: Implement a Firebase Cloud Function that triggers on file upload to Firebase Storage. This function will automatically generate a thumbnail (e.g., 100x100 pixels) and save it to a different path in the user's storage bucket. The URLs for both the original and the thumbnail must then be updated in the user's document in the users collection.","title":"5. File Storage Refactoring"},{"location":"FIREBASE_MIGRATION/#6-application-logic-refactoring","text":"All application code that currently interacts with the PostgreSQL database via SQLAlchemy must be rewritten to use the Firebase Admin SDK for Python. A comprehensive code review must be performed to identify all instances of db.session usage. All routes in auth , admin , user , match , and group blueprints must be refactored. All forms in forms.py that rely on database queries for validation must be updated. All utility functions in utils.py that perform database operations must be rewritten.","title":"6. Application Logic Refactoring"},{"location":"FIREBASE_MIGRATION/#7-environment-and-configuration","text":"Firebase Credentials: The Firebase Admin SDK requires service account credentials. These credentials (a JSON file) must not be committed to the repository. They should be stored securely as a GitHub secret and loaded into the production environment during the deployment workflow. Deployment Workflow: The .github/workflows/deploy.yml file must be updated. The db service and the postgres_data volume must be removed. The workflow will need a new step to securely load the Firebase service account key into the server environment for the application to use.","title":"7. Environment and Configuration"},{"location":"FIREBASE_MIGRATION/#8-corner-cases-and-considerations","text":"Data Migration: The current user base is small or non-existent, so a complex data migration script from PostgreSQL to Firebase is not required at this stage. The new system will start fresh. Error Handling: All calls to Firebase services must be wrapped in appropriate try...except blocks to handle potential API errors gracefully (e.g., permission denied, document not found). Security Rules: This is a critical requirement. Write and test comprehensive security rules for both Firestore and Firebase Storage. The default should be to deny all access. Rules should be written to grant access only to authenticated users for their own data. Administrative access should also be handled via security rules where possible. Uniqueness Constraints: Firestore does not enforce unique field values (e.g., for username ). This must be handled by the application logic. When a user registers, the application must first query the users collection to ensure the chosen username is not already taken before creating the new user. This must be done in a transaction to avoid race conditions.","title":"8. Corner Cases and Considerations"},{"location":"FIREBASE_MIGRATION/#9-definition-of-done","text":"The migration will be considered complete when all of the following criteria are met: [ ] All PostgreSQL-related code ( SQLAlchemy , psycopg2-binary ) has been removed from the application. [ ] All user authentication flows (register, login, logout, password reset) are fully functional using Firebase Authentication. [ ] The initial admin user setup flow is working correctly. [ ] Users can upload and change their profile pictures, and thumbnails are generated and displayed correctly. [ ] All \"friends\" features (sending requests, accepting requests, viewing friends) are fully functional. [ ] All \"groups\" features (creating, editing, joining, viewing) are fully functional. [ ] All \"match\" features (creating matches, viewing leaderboard) are fully functional. [ ] All administrative functions are working correctly. [ ] The deployment workflow is updated and successfully deploys the new Firebase-backed application. [ ] Comprehensive security rules for Firestore and Firebase Storage are implemented and tested. [ ] The application is stable and the original 500 error is resolved.","title":"9. Definition of Done"},{"location":"REFACTOR/","text":"Refactoring Opportunities This document outlines potential refactoring opportunities to improve the efficiency and scalability of the pickaladder application. 1. Database Optimization The current implementation uses direct psycopg2 calls for database interaction. While this works for a small application, it can lead to performance issues and maintainability problems as the application grows. Introduce an ORM: Using an Object-Relational Mapper (ORM) like SQLAlchemy would provide a more robust and maintainable way to interact with the database. An ORM can help prevent SQL injection vulnerabilities, simplify queries, and improve code readability. Connection Pooling: The application already uses a simple connection pool, which is good. However, for a high-traffic application, it might be beneficial to switch to a more advanced connection pooling solution like PgBouncer. Optimize Queries: The inject_user context processor runs a query to fetch user data on every request. This could be optimized by caching user data in the session or using a more efficient caching mechanism like Redis. 2. Caching The application does not currently use any caching. Implementing a caching layer could significantly improve performance, especially for frequently accessed data. Cache User Data: As mentioned above, caching user data would reduce the number of database queries. Cache Leaderboard Data: The leaderboard is likely to be a frequently accessed page. Caching the leaderboard data would reduce the load on the database and improve response times. Use a Caching Backend: Implementing a caching solution like Redis or Memcached would provide a centralized caching layer that can be used throughout the application. 3. Asynchronous Tasks Some tasks, like sending emails, can be time-consuming and block the request-response cycle. These tasks should be handled asynchronously. Use a Task Queue: A task queue like Celery could be used to handle long-running tasks in the background. This would improve the user experience by reducing response times for requests that trigger these tasks. 4. Static Asset Management The application currently stores profile pictures directly in the database as BYTEA data. This is inefficient and can lead to performance problems. Store Files on the Filesystem: Profile pictures should be stored on the filesystem, and only the path to the file should be stored in the database. Use a CDN: For a large-scale application, using a Content Delivery Network (CDN) to serve static assets like profile pictures would significantly improve performance. 5. Frontend Assets The frontend directory contains a boilerplate React application that is not currently used. The application is a traditional server-side rendered Flask application. Remove Unused Frontend: The unused React frontend should be removed to avoid confusion and reduce the size of the codebase. Modernize Frontend: If a more interactive frontend is desired, the application could be migrated to a modern JavaScript framework like React or Vue.js. This would involve creating a separate frontend application that communicates with the Flask backend via a REST API. This would also allow for a more modern and responsive user interface. Deeper Refactoring Opportunities Based on a more in-depth review of the route handlers and application logic, here are some more specific refactoring opportunities. 1. Code Structure and Duplication Refactor User Creation Logic: The auth/routes.py file has duplicate code for creating a user in the register and install routes. This should be extracted into a single helper function to reduce redundancy and improve maintainability. Encapsulate Business Logic: The route handlers in admin/routes.py , user/routes.py , and match/routes.py contain a lot of business logic (e.g., generating users, handling friendships, calculating records). This logic should be moved into separate \"service\" or \"model\" classes. This would make the code more modular, easier to test, and closer to the Single Responsibility Principle. For example, a FriendshipService could handle all the logic related to adding, accepting, and declining friend requests. Configuration Management: The Flask app configuration in pickaladder/__init__.py is a mix of hardcoded values and environment variables. This should be standardized to use a configuration file (e.g., config.py ) or a library like Dynaconf to manage different environments (development, testing, production) more effectively. 2. Security Enhancements Secure Password Reset: The current password reset mechanism in auth/routes.py is insecure because it relies only on the user's email address. This should be replaced with a token-based system. When a user requests a password reset, a unique, single-use, and time-limited token should be generated and sent to the user's email. The user can then use this token to reset their password. CSRF Protection: The admin routes that perform state-changing operations (e.g., deleting users, resetting the database) are vulnerable to Cross-Site Request Forgery (CSRF) attacks. Flask-WTF or a similar library should be used to add CSRF protection to all forms and state-changing requests. Plain Text Passwords in Email: The admin_reset_password function in admin/routes.py sends a new password to the user in plain text. This is a major security risk. This feature should be changed to send a password reset link instead, allowing the user to set their own password. 3. Database and Query Optimization Avoid N+1 Queries: Several routes, particularly in user/routes.py , suffer from the N+1 query problem. For example, fetching a list of users and then fetching their friends in a loop. These queries should be optimized using SQL JOINs to fetch all the necessary data in a single query. Refactor Complex Queries: The queries for calculating player records in match/routes.py are very complex and inefficient. These could be simplified and made more performant by creating database views or functions to handle the calculations. Pagination: The users page fetches all users at once. This will not scale. Pagination should be implemented for all lists of data (users, matches, etc.) to ensure the application remains performant as the amount of data grows. 4. Error Handling and Input Validation Consistent Error Handling: The application's error handling is inconsistent. A global error handling strategy should be implemented. For example, creating custom exception classes and using Flask's @app.errorhandler to handle them consistently across the application. Input Validation: There is a lack of input validation in many places, such as the match creation form. All user input should be validated on the server side to prevent invalid data from being saved to the database. Libraries like Marshmallow or Pydantic can be used to define schemas for input data and validate it automatically.","title":"Refactoring Opportunities"},{"location":"REFACTOR/#refactoring-opportunities","text":"This document outlines potential refactoring opportunities to improve the efficiency and scalability of the pickaladder application.","title":"Refactoring Opportunities"},{"location":"REFACTOR/#1-database-optimization","text":"The current implementation uses direct psycopg2 calls for database interaction. While this works for a small application, it can lead to performance issues and maintainability problems as the application grows. Introduce an ORM: Using an Object-Relational Mapper (ORM) like SQLAlchemy would provide a more robust and maintainable way to interact with the database. An ORM can help prevent SQL injection vulnerabilities, simplify queries, and improve code readability. Connection Pooling: The application already uses a simple connection pool, which is good. However, for a high-traffic application, it might be beneficial to switch to a more advanced connection pooling solution like PgBouncer. Optimize Queries: The inject_user context processor runs a query to fetch user data on every request. This could be optimized by caching user data in the session or using a more efficient caching mechanism like Redis.","title":"1. Database Optimization"},{"location":"REFACTOR/#2-caching","text":"The application does not currently use any caching. Implementing a caching layer could significantly improve performance, especially for frequently accessed data. Cache User Data: As mentioned above, caching user data would reduce the number of database queries. Cache Leaderboard Data: The leaderboard is likely to be a frequently accessed page. Caching the leaderboard data would reduce the load on the database and improve response times. Use a Caching Backend: Implementing a caching solution like Redis or Memcached would provide a centralized caching layer that can be used throughout the application.","title":"2. Caching"},{"location":"REFACTOR/#3-asynchronous-tasks","text":"Some tasks, like sending emails, can be time-consuming and block the request-response cycle. These tasks should be handled asynchronously. Use a Task Queue: A task queue like Celery could be used to handle long-running tasks in the background. This would improve the user experience by reducing response times for requests that trigger these tasks.","title":"3. Asynchronous Tasks"},{"location":"REFACTOR/#4-static-asset-management","text":"The application currently stores profile pictures directly in the database as BYTEA data. This is inefficient and can lead to performance problems. Store Files on the Filesystem: Profile pictures should be stored on the filesystem, and only the path to the file should be stored in the database. Use a CDN: For a large-scale application, using a Content Delivery Network (CDN) to serve static assets like profile pictures would significantly improve performance.","title":"4. Static Asset Management"},{"location":"REFACTOR/#5-frontend-assets","text":"The frontend directory contains a boilerplate React application that is not currently used. The application is a traditional server-side rendered Flask application. Remove Unused Frontend: The unused React frontend should be removed to avoid confusion and reduce the size of the codebase. Modernize Frontend: If a more interactive frontend is desired, the application could be migrated to a modern JavaScript framework like React or Vue.js. This would involve creating a separate frontend application that communicates with the Flask backend via a REST API. This would also allow for a more modern and responsive user interface.","title":"5. Frontend Assets"},{"location":"REFACTOR/#deeper-refactoring-opportunities","text":"Based on a more in-depth review of the route handlers and application logic, here are some more specific refactoring opportunities.","title":"Deeper Refactoring Opportunities"},{"location":"REFACTOR/#1-code-structure-and-duplication","text":"Refactor User Creation Logic: The auth/routes.py file has duplicate code for creating a user in the register and install routes. This should be extracted into a single helper function to reduce redundancy and improve maintainability. Encapsulate Business Logic: The route handlers in admin/routes.py , user/routes.py , and match/routes.py contain a lot of business logic (e.g., generating users, handling friendships, calculating records). This logic should be moved into separate \"service\" or \"model\" classes. This would make the code more modular, easier to test, and closer to the Single Responsibility Principle. For example, a FriendshipService could handle all the logic related to adding, accepting, and declining friend requests. Configuration Management: The Flask app configuration in pickaladder/__init__.py is a mix of hardcoded values and environment variables. This should be standardized to use a configuration file (e.g., config.py ) or a library like Dynaconf to manage different environments (development, testing, production) more effectively.","title":"1. Code Structure and Duplication"},{"location":"REFACTOR/#2-security-enhancements","text":"Secure Password Reset: The current password reset mechanism in auth/routes.py is insecure because it relies only on the user's email address. This should be replaced with a token-based system. When a user requests a password reset, a unique, single-use, and time-limited token should be generated and sent to the user's email. The user can then use this token to reset their password. CSRF Protection: The admin routes that perform state-changing operations (e.g., deleting users, resetting the database) are vulnerable to Cross-Site Request Forgery (CSRF) attacks. Flask-WTF or a similar library should be used to add CSRF protection to all forms and state-changing requests. Plain Text Passwords in Email: The admin_reset_password function in admin/routes.py sends a new password to the user in plain text. This is a major security risk. This feature should be changed to send a password reset link instead, allowing the user to set their own password.","title":"2. Security Enhancements"},{"location":"REFACTOR/#3-database-and-query-optimization","text":"Avoid N+1 Queries: Several routes, particularly in user/routes.py , suffer from the N+1 query problem. For example, fetching a list of users and then fetching their friends in a loop. These queries should be optimized using SQL JOINs to fetch all the necessary data in a single query. Refactor Complex Queries: The queries for calculating player records in match/routes.py are very complex and inefficient. These could be simplified and made more performant by creating database views or functions to handle the calculations. Pagination: The users page fetches all users at once. This will not scale. Pagination should be implemented for all lists of data (users, matches, etc.) to ensure the application remains performant as the amount of data grows.","title":"3. Database and Query Optimization"},{"location":"REFACTOR/#4-error-handling-and-input-validation","text":"Consistent Error Handling: The application's error handling is inconsistent. A global error handling strategy should be implemented. For example, creating custom exception classes and using Flask's @app.errorhandler to handle them consistently across the application. Input Validation: There is a lack of input validation in many places, such as the match creation form. All user input should be validated on the server side to prevent invalid data from being saved to the database. Libraries like Marshmallow or Pydantic can be used to define schemas for input data and validate it automatically.","title":"4. Error Handling and Input Validation"},{"location":"REQUIREMENTS/","text":"pickaladder Application Requirements This document outlines the requirements for the pickaladder application. Functional Requirements User Management User Registration: Users can create an account with a username, password, email address, and name. Email Verification: Email verification can be enforced by an administrator. When enabled, users must verify their email address before they can log in. This setting is disabled by default. User Login: Users can log in with their username and password. Password Reset: Users can reset their password if they forget it. Profile Updates: Users can update their DUPR rating, password, and profile picture from their dashboard. Friend Management Find Friends: Users can find other users to be friends with. Add Friends: Users can add other users as friends. View Friends: Users can view a list of their friends. Friends of Friends: Users can see a list of \"friends of friends\" to get recommendations for new friends. View Friend Profile: Users can view a friend's profile. Gameplay Match Creation: Users can create matches with their friends. Match Viewing: Users can view the details of a match, including an emphasized icon for the winner and each player's win/loss record. The player's icon and username are also clickable links to their profile page. Leaderboard: The application has a leaderboard that shows the top 10 players by average score. Match History: The user profile page displays a history of the user's matches. The winning score is bolded, and each match is a clickable link to the match details page. Admin Functionality Admin Panel: Admin users have access to an admin panel. User Management: Admins can delete users, promote users to admins, reset user passwords, and manually verify a user's email address. Settings Management: Admins can enable or disable the requirement for email verification from the admin panel. Database Management: Admins can reset the database. Data Generation: Admins can generate random users, matches, and groups for testing purposes. Non-Functional Requirements Architecture Monolithic Application: The application is a monolithic web application built with Flask and PostgreSQL. Containerized: The application is containerized with Docker and deployed with docker-compose. Blueprint-based: The Flask application is organized using a blueprint-based structure. Database Database: The application uses a PostgreSQL database. Connection Pooling: The application uses a connection pool to manage database connections. Database Initialization: The database is automatically initialized and migrated when the application starts. Security UUIDs: User and match IDs are UUIDs to enhance privacy. Password Hashing: Passwords are securely hashed using pbkdf2:sha256 with 150,000 iterations. The application also includes a mechanism to re-hash the passwords of existing users on the fly when they log in. User Interface Modern Design: The application has a modern, clean, and responsive user interface with a Google-inspired design. Custom Styling: The application uses a custom stylesheet and does not depend on any external CSS frameworks like Bootstrap. Login Page: The login page does not show a redundant \"Please log in to access this page.\" message or a \"LOGIN\" button in the navigation bar. Code Quality Linting: The project uses ruff for linting and code formatting. Testing: The project has a basic test suite. Future Enhancements Usability Improvements Real-time Updates: The application currently requires a page reload to see updates. Implementing real-time updates using WebSockets would provide a much better user experience. For example, the leaderboard could update in real-time as matches are completed. Improved User Profiles: User profiles could be enhanced to include more information, such as a user's match history, win/loss record, and a short bio. Friend Request Notifications: When a user receives a friend request, they should receive a notification. This could be an in-app notification or an email. Match Confirmation: When a match is recorded, both players should be required to confirm the score. This would help prevent disputes and ensure the accuracy of match results. New User Features Match Scheduling: Users should be able to schedule matches with other players. This would involve selecting a date, time, and location for the match. Double Matches: The current application only supports singles matches. Adding support for doubles matches would be a valuable feature for many players. Player Statistics: Users should be able to view detailed statistics about their own play, such as their win/loss record against specific opponents, their performance over time, and other metrics. Find a Partner: A feature that allows users to find other players of a similar skill level to play with would be a great addition. Social Sharing: Users should be able to share their match results and other achievements on social media. Match Location: Users should be able to optionally record the location of a match. This could be a simple text field or integrated with a mapping service. This would be useful for tracking where matches are played and for facilities to see which courts are being used. Manager Features Tournament Brackets: The application should support the creation and management of tournament brackets. This would include single-elimination, double-elimination, and round-robin formats. Facility Management: Managers should be able to manage facility information, such as court availability and hours of operation. Event Registration: The application should allow users to register for events and tournaments. This would include collecting registration fees and managing participant lists. Announcements: Managers should be able to send announcements to all participants in an event or to all users of the application. Reporting: The application should provide detailed reports on event participation, match results, and other key metrics. This would be useful for analyzing the success of events and for planning future ones. Security Input Validation: Implement robust input validation on all user-supplied data. Password Policies: Enforce strong password policies. Session Management: Implement secure session management practices. Rate Limiting: Implement rate limiting on sensitive endpoints. Quality Type Checking: Add static type checking with mypy . Comprehensive Testing: Expand the test suite to include integration and end-to-end tests. Code Coverage: Measure code coverage to identify untested parts of the codebase. Documentation API Documentation: Generate API documentation. User Guide: Create a comprehensive user guide. CI/CD Automated Deployments: Implement a CI/CD pipeline for automated testing and deployment. Infrastructure as Code: Use a tool like Terraform to manage infrastructure as code. Configuration Configuration File: Use a configuration file instead of environment variables for all settings. Logging: Implement a more robust and configurable logging system. Other Features Multiple Ladder Rankings: Add support for multiple ladder ranking systems. Customizable Branding: Allow admins to customize the branding of the admin page. Terms of Service: Add a terms of service page. Data Export: Allow users to export their data. Known Issues This section documents some of the known issues in the application. \"Method Not Allowed\" on root page login: The root URL / is mapped to the login page, but it does not accept POST requests. This has been fixed by allowing POST requests on the root URL. \"Method Not Allowed\" on friend requests: The buttons for accepting and declining friend requests were implemented as links, which send GET requests to a POST-only route. This has been fixed by replacing the links with forms that submit POST requests. CSRF error on friend requests: The forms for accepting and declining friend requests were missing the CSRF token. This has been fixed by adding the CSRF token to the forms. Deeper Feature Suggestions Based on a more in-depth review of the codebase, here are some more detailed feature suggestions. Usability Improvements Autocomplete for User Search: In the user search and \"Create Match\" opponent selection, implement an autocomplete feature to make it easier to find users, especially in a system with many users. Interactive Leaderboard: The leaderboard could be made more interactive. For example, allowing users to see their own rank even if they are not in the top 10, and showing how many places they have moved up or down since the last time they checked. Dashboard Feed: The user dashboard could be enhanced to show a \"feed\" of recent activity from their friends, such as recently played matches. New User Features Advanced Ranking System: Implement a more advanced ranking system like Elo or Glicko-2. These systems are better at predicting match outcomes and provide a more accurate measure of a player's skill level. This would also allow for features like predicting the outcome of a match before it's played. Public Profile URLs: Allow users to have a public profile URL that they can share with others, even those who are not registered on the site. This could be an optional feature that users can enable or disable. Match History Charts: On a user's profile, display charts and graphs to visualize their match history, such as their win/loss ratio over time, or their performance against different opponents. Achievements/Badges: Add a system of achievements or badges that users can earn for reaching certain milestones (e.g., \"Played 10 matches,\" \"First win,\" \"On a winning streak\"). Manager Features Multiple Ladder Types: Allow facility managers to create and manage different types of ladders, such as singles, doubles, mixed doubles, age-based ladders, or skill-level-based ladders (e.g., 3.0-3.5, 4.0-4.5). Court Reservation System: Integrate a court reservation system. This would allow managers to define the courts available at their facility and allow users to book courts for their matches. Event-specific Leaderboards: For tournaments or leagues, create separate leaderboards that are specific to that event, in addition to the overall site-wide leaderboard. Broadcast Messaging: Give managers the ability to send broadcast messages to all participants of a specific tournament or league, or to all users who have played at their facility. This could be used for announcements, updates, or promotions.","title":"pickaladder Application Requirements"},{"location":"REQUIREMENTS/#pickaladder-application-requirements","text":"This document outlines the requirements for the pickaladder application.","title":"pickaladder Application Requirements"},{"location":"REQUIREMENTS/#functional-requirements","text":"","title":"Functional Requirements"},{"location":"REQUIREMENTS/#user-management","text":"User Registration: Users can create an account with a username, password, email address, and name. Email Verification: Email verification can be enforced by an administrator. When enabled, users must verify their email address before they can log in. This setting is disabled by default. User Login: Users can log in with their username and password. Password Reset: Users can reset their password if they forget it. Profile Updates: Users can update their DUPR rating, password, and profile picture from their dashboard.","title":"User Management"},{"location":"REQUIREMENTS/#friend-management","text":"Find Friends: Users can find other users to be friends with. Add Friends: Users can add other users as friends. View Friends: Users can view a list of their friends. Friends of Friends: Users can see a list of \"friends of friends\" to get recommendations for new friends. View Friend Profile: Users can view a friend's profile.","title":"Friend Management"},{"location":"REQUIREMENTS/#gameplay","text":"Match Creation: Users can create matches with their friends. Match Viewing: Users can view the details of a match, including an emphasized icon for the winner and each player's win/loss record. The player's icon and username are also clickable links to their profile page. Leaderboard: The application has a leaderboard that shows the top 10 players by average score. Match History: The user profile page displays a history of the user's matches. The winning score is bolded, and each match is a clickable link to the match details page.","title":"Gameplay"},{"location":"REQUIREMENTS/#admin-functionality","text":"Admin Panel: Admin users have access to an admin panel. User Management: Admins can delete users, promote users to admins, reset user passwords, and manually verify a user's email address. Settings Management: Admins can enable or disable the requirement for email verification from the admin panel. Database Management: Admins can reset the database. Data Generation: Admins can generate random users, matches, and groups for testing purposes.","title":"Admin Functionality"},{"location":"REQUIREMENTS/#non-functional-requirements","text":"","title":"Non-Functional Requirements"},{"location":"REQUIREMENTS/#architecture","text":"Monolithic Application: The application is a monolithic web application built with Flask and PostgreSQL. Containerized: The application is containerized with Docker and deployed with docker-compose. Blueprint-based: The Flask application is organized using a blueprint-based structure.","title":"Architecture"},{"location":"REQUIREMENTS/#database","text":"Database: The application uses a PostgreSQL database. Connection Pooling: The application uses a connection pool to manage database connections. Database Initialization: The database is automatically initialized and migrated when the application starts.","title":"Database"},{"location":"REQUIREMENTS/#security","text":"UUIDs: User and match IDs are UUIDs to enhance privacy. Password Hashing: Passwords are securely hashed using pbkdf2:sha256 with 150,000 iterations. The application also includes a mechanism to re-hash the passwords of existing users on the fly when they log in.","title":"Security"},{"location":"REQUIREMENTS/#user-interface","text":"Modern Design: The application has a modern, clean, and responsive user interface with a Google-inspired design. Custom Styling: The application uses a custom stylesheet and does not depend on any external CSS frameworks like Bootstrap. Login Page: The login page does not show a redundant \"Please log in to access this page.\" message or a \"LOGIN\" button in the navigation bar.","title":"User Interface"},{"location":"REQUIREMENTS/#code-quality","text":"Linting: The project uses ruff for linting and code formatting. Testing: The project has a basic test suite.","title":"Code Quality"},{"location":"REQUIREMENTS/#future-enhancements","text":"","title":"Future Enhancements"},{"location":"REQUIREMENTS/#usability-improvements","text":"Real-time Updates: The application currently requires a page reload to see updates. Implementing real-time updates using WebSockets would provide a much better user experience. For example, the leaderboard could update in real-time as matches are completed. Improved User Profiles: User profiles could be enhanced to include more information, such as a user's match history, win/loss record, and a short bio. Friend Request Notifications: When a user receives a friend request, they should receive a notification. This could be an in-app notification or an email. Match Confirmation: When a match is recorded, both players should be required to confirm the score. This would help prevent disputes and ensure the accuracy of match results.","title":"Usability Improvements"},{"location":"REQUIREMENTS/#new-user-features","text":"Match Scheduling: Users should be able to schedule matches with other players. This would involve selecting a date, time, and location for the match. Double Matches: The current application only supports singles matches. Adding support for doubles matches would be a valuable feature for many players. Player Statistics: Users should be able to view detailed statistics about their own play, such as their win/loss record against specific opponents, their performance over time, and other metrics. Find a Partner: A feature that allows users to find other players of a similar skill level to play with would be a great addition. Social Sharing: Users should be able to share their match results and other achievements on social media. Match Location: Users should be able to optionally record the location of a match. This could be a simple text field or integrated with a mapping service. This would be useful for tracking where matches are played and for facilities to see which courts are being used.","title":"New User Features"},{"location":"REQUIREMENTS/#manager-features","text":"Tournament Brackets: The application should support the creation and management of tournament brackets. This would include single-elimination, double-elimination, and round-robin formats. Facility Management: Managers should be able to manage facility information, such as court availability and hours of operation. Event Registration: The application should allow users to register for events and tournaments. This would include collecting registration fees and managing participant lists. Announcements: Managers should be able to send announcements to all participants in an event or to all users of the application. Reporting: The application should provide detailed reports on event participation, match results, and other key metrics. This would be useful for analyzing the success of events and for planning future ones.","title":"Manager Features"},{"location":"REQUIREMENTS/#security_1","text":"Input Validation: Implement robust input validation on all user-supplied data. Password Policies: Enforce strong password policies. Session Management: Implement secure session management practices. Rate Limiting: Implement rate limiting on sensitive endpoints.","title":"Security"},{"location":"REQUIREMENTS/#quality","text":"Type Checking: Add static type checking with mypy . Comprehensive Testing: Expand the test suite to include integration and end-to-end tests. Code Coverage: Measure code coverage to identify untested parts of the codebase.","title":"Quality"},{"location":"REQUIREMENTS/#documentation","text":"API Documentation: Generate API documentation. User Guide: Create a comprehensive user guide.","title":"Documentation"},{"location":"REQUIREMENTS/#cicd","text":"Automated Deployments: Implement a CI/CD pipeline for automated testing and deployment. Infrastructure as Code: Use a tool like Terraform to manage infrastructure as code.","title":"CI/CD"},{"location":"REQUIREMENTS/#configuration","text":"Configuration File: Use a configuration file instead of environment variables for all settings. Logging: Implement a more robust and configurable logging system.","title":"Configuration"},{"location":"REQUIREMENTS/#other-features","text":"Multiple Ladder Rankings: Add support for multiple ladder ranking systems. Customizable Branding: Allow admins to customize the branding of the admin page. Terms of Service: Add a terms of service page. Data Export: Allow users to export their data.","title":"Other Features"},{"location":"REQUIREMENTS/#known-issues","text":"This section documents some of the known issues in the application. \"Method Not Allowed\" on root page login: The root URL / is mapped to the login page, but it does not accept POST requests. This has been fixed by allowing POST requests on the root URL. \"Method Not Allowed\" on friend requests: The buttons for accepting and declining friend requests were implemented as links, which send GET requests to a POST-only route. This has been fixed by replacing the links with forms that submit POST requests. CSRF error on friend requests: The forms for accepting and declining friend requests were missing the CSRF token. This has been fixed by adding the CSRF token to the forms.","title":"Known Issues"},{"location":"REQUIREMENTS/#deeper-feature-suggestions","text":"Based on a more in-depth review of the codebase, here are some more detailed feature suggestions.","title":"Deeper Feature Suggestions"},{"location":"REQUIREMENTS/#usability-improvements_1","text":"Autocomplete for User Search: In the user search and \"Create Match\" opponent selection, implement an autocomplete feature to make it easier to find users, especially in a system with many users. Interactive Leaderboard: The leaderboard could be made more interactive. For example, allowing users to see their own rank even if they are not in the top 10, and showing how many places they have moved up or down since the last time they checked. Dashboard Feed: The user dashboard could be enhanced to show a \"feed\" of recent activity from their friends, such as recently played matches.","title":"Usability Improvements"},{"location":"REQUIREMENTS/#new-user-features_1","text":"Advanced Ranking System: Implement a more advanced ranking system like Elo or Glicko-2. These systems are better at predicting match outcomes and provide a more accurate measure of a player's skill level. This would also allow for features like predicting the outcome of a match before it's played. Public Profile URLs: Allow users to have a public profile URL that they can share with others, even those who are not registered on the site. This could be an optional feature that users can enable or disable. Match History Charts: On a user's profile, display charts and graphs to visualize their match history, such as their win/loss ratio over time, or their performance against different opponents. Achievements/Badges: Add a system of achievements or badges that users can earn for reaching certain milestones (e.g., \"Played 10 matches,\" \"First win,\" \"On a winning streak\").","title":"New User Features"},{"location":"REQUIREMENTS/#manager-features_1","text":"Multiple Ladder Types: Allow facility managers to create and manage different types of ladders, such as singles, doubles, mixed doubles, age-based ladders, or skill-level-based ladders (e.g., 3.0-3.5, 4.0-4.5). Court Reservation System: Integrate a court reservation system. This would allow managers to define the courts available at their facility and allow users to book courts for their matches. Event-specific Leaderboards: For tournaments or leagues, create separate leaderboards that are specific to that event, in addition to the overall site-wide leaderboard. Broadcast Messaging: Give managers the ability to send broadcast messages to all participants of a specific tournament or league, or to all users who have played at their facility. This could be used for announcements, updates, or promotions.","title":"Manager Features"},{"location":"SECURITY/","text":"Security Analysis and Fixes This document provides a security analysis of the pickaladder application and documents the fixes that have been implemented. 1. Authentication and Authorization 1.1. Insecure Email Verification (High Severity) - FIXED Observation: The original email verification mechanism was insecure. It relied on the user's email address in a GET request parameter to verify the user. An attacker could easily craft a URL to verify any user's email if they knew their email address. Fix: The email verification flow has been updated to use a secure, token-based system. When a user registers, a unique, single-use, and time-limited token is generated using itsdangerous . This token is emailed to the user. When the user clicks the link, the application validates the token and its expiration date before marking the email as verified. This prevents attackers from verifying emails on behalf of other users. 1.2. Plaintext Password in Email (High Severity) - NOT PRESENT Observation in Report: The security report mentioned that the admin_reset_password function in admin/routes.py generated a new password and emailed it to the user in plaintext. Finding: A code review found that this vulnerability was not present in the codebase. The admin_reset_password function correctly uses the same secure, token-based password reset mechanism as the user-facing \"forgot password\" feature. No plaintext passwords are sent via email. 1.3. Authorization Checks Observation: The admin blueprint is protected by a @bp.before_request check, which is good. However, access control within the user-facing parts of the application should be reviewed. For example, any logged-in user can view the profile page of any other user. Recommendation: While making user profiles public to other logged-in users might be an intentional design choice, it's a privacy consideration that should be documented. For any sensitive data or actions, ensure that there are explicit checks to verify that the logged-in user is authorized to perform that action (e.g., if session[USER_ID] == user_id_from_url ). 2. Web Application Vulnerabilities 2.1. Cross-Site Request Forgery (CSRF) (High Severity) - FIXED Observation: Many state-changing actions in the admin panel (e.g., deleting users, resetting the database) were performed via GET requests and lacked CSRF protection. A malicious website could trick a logged-in admin into clicking a link that performed a destructive action without their consent. Fix: All vulnerable, state-changing links in the admin panel have been converted into HTML forms that use the POST method. Flask-WTF has been used to add a unique CSRF token to each of these forms. The server-side routes now validate this token on every request, effectively preventing CSRF attacks. 2.2. SQL Injection (Low Severity) Observation: The application uses psycopg2 's parameter substitution (e.g., cur.execute(\"... WHERE id = %s\", (user_id,)) ), which correctly prevents SQL injection in query values. However, table and column names are often inserted into SQL strings using f-strings. While these currently come from constants and are safe, this is a risky practice. If these values could ever be influenced by user input in the future, it would create a SQL injection vulnerability. Recommendation: Continue to use parameterized queries for all values. For dynamic table or column names, use a whitelist approach to validate the input against a list of known, safe values before incorporating it into a query. 2.3. Cross-Site Scripting (XSS) (Informational) Observation: The application uses Jinja2 for templating, which has auto-escaping enabled by default. This provides good baseline protection against XSS attacks. Recommendation: Continue to rely on Jinja2's auto-escaping. Be cautious of ever using the |safe filter, as it bypasses this protection and could introduce a vulnerability if used on untrusted user input. 3. Dependency and Environment Management 3.1. Outdated and Unpinned Dependencies (Medium Severity) - FIXED Observation: The requirements.txt file had several unpinned dependencies and some outdated pinned dependencies. This could lead to unpredictable builds or the accidental installation of packages with known vulnerabilities. Fix: All dependencies in requirements.txt have been pinned to specific, known-good versions. All packages have been upgraded to their latest secure versions as of the time of the fix. This ensures a reproducible and secure environment. 3.2. CI/CD Pipeline Enforcement (Low Severity) Observation: The CI pipeline in .github/workflows/ci.yml is very strong, including bandit for static analysis and trivy for vulnerability scanning. Recommendation: Ensure the pipeline is configured to fail the build if significant vulnerabilities are found. The current trivy configuration ( exit-code: '1' ) does this, which is great. Consider adding a similar flag to the bandit step to fail the build for high-severity findings (e.g., bandit -r . -ll -c bandit.yaml ). 4. General Security Best Practices 4.1. Use of Security Headers Observation: The application does not appear to be setting modern security headers. Recommendation: Use a library like Flask-Talisman to easily set HTTP security headers such as Content-Security-Policy (CSP) , Strict-Transport-Security (HSTS) , X-Content-Type-Options , and X-Frame-Options . These headers can help mitigate a wide range of attacks, including XSS and clickjacking. 4.2. Sensitive Data in Session Observation: The Flask session is used to store the user's ID and admin status. Flask's default session is signed but not encrypted. Recommendation: This is generally acceptable for non-sensitive data like a user ID. However, be mindful not to store any highly sensitive information in the session. If you ever need to, consider enabling server-side sessions where the session data is stored in a database or cache (like Redis) and only a session identifier is sent to the client.","title":"Security Analysis and Fixes"},{"location":"SECURITY/#security-analysis-and-fixes","text":"This document provides a security analysis of the pickaladder application and documents the fixes that have been implemented.","title":"Security Analysis and Fixes"},{"location":"SECURITY/#1-authentication-and-authorization","text":"","title":"1. Authentication and Authorization"},{"location":"SECURITY/#11-insecure-email-verification-high-severity-fixed","text":"Observation: The original email verification mechanism was insecure. It relied on the user's email address in a GET request parameter to verify the user. An attacker could easily craft a URL to verify any user's email if they knew their email address. Fix: The email verification flow has been updated to use a secure, token-based system. When a user registers, a unique, single-use, and time-limited token is generated using itsdangerous . This token is emailed to the user. When the user clicks the link, the application validates the token and its expiration date before marking the email as verified. This prevents attackers from verifying emails on behalf of other users.","title":"1.1. Insecure Email Verification (High Severity) - FIXED"},{"location":"SECURITY/#12-plaintext-password-in-email-high-severity-not-present","text":"Observation in Report: The security report mentioned that the admin_reset_password function in admin/routes.py generated a new password and emailed it to the user in plaintext. Finding: A code review found that this vulnerability was not present in the codebase. The admin_reset_password function correctly uses the same secure, token-based password reset mechanism as the user-facing \"forgot password\" feature. No plaintext passwords are sent via email.","title":"1.2. Plaintext Password in Email (High Severity) - NOT PRESENT"},{"location":"SECURITY/#13-authorization-checks","text":"Observation: The admin blueprint is protected by a @bp.before_request check, which is good. However, access control within the user-facing parts of the application should be reviewed. For example, any logged-in user can view the profile page of any other user. Recommendation: While making user profiles public to other logged-in users might be an intentional design choice, it's a privacy consideration that should be documented. For any sensitive data or actions, ensure that there are explicit checks to verify that the logged-in user is authorized to perform that action (e.g., if session[USER_ID] == user_id_from_url ).","title":"1.3. Authorization Checks"},{"location":"SECURITY/#2-web-application-vulnerabilities","text":"","title":"2. Web Application Vulnerabilities"},{"location":"SECURITY/#21-cross-site-request-forgery-csrf-high-severity-fixed","text":"Observation: Many state-changing actions in the admin panel (e.g., deleting users, resetting the database) were performed via GET requests and lacked CSRF protection. A malicious website could trick a logged-in admin into clicking a link that performed a destructive action without their consent. Fix: All vulnerable, state-changing links in the admin panel have been converted into HTML forms that use the POST method. Flask-WTF has been used to add a unique CSRF token to each of these forms. The server-side routes now validate this token on every request, effectively preventing CSRF attacks.","title":"2.1. Cross-Site Request Forgery (CSRF) (High Severity) - FIXED"},{"location":"SECURITY/#22-sql-injection-low-severity","text":"Observation: The application uses psycopg2 's parameter substitution (e.g., cur.execute(\"... WHERE id = %s\", (user_id,)) ), which correctly prevents SQL injection in query values. However, table and column names are often inserted into SQL strings using f-strings. While these currently come from constants and are safe, this is a risky practice. If these values could ever be influenced by user input in the future, it would create a SQL injection vulnerability. Recommendation: Continue to use parameterized queries for all values. For dynamic table or column names, use a whitelist approach to validate the input against a list of known, safe values before incorporating it into a query.","title":"2.2. SQL Injection (Low Severity)"},{"location":"SECURITY/#23-cross-site-scripting-xss-informational","text":"Observation: The application uses Jinja2 for templating, which has auto-escaping enabled by default. This provides good baseline protection against XSS attacks. Recommendation: Continue to rely on Jinja2's auto-escaping. Be cautious of ever using the |safe filter, as it bypasses this protection and could introduce a vulnerability if used on untrusted user input.","title":"2.3. Cross-Site Scripting (XSS) (Informational)"},{"location":"SECURITY/#3-dependency-and-environment-management","text":"","title":"3. Dependency and Environment Management"},{"location":"SECURITY/#31-outdated-and-unpinned-dependencies-medium-severity-fixed","text":"Observation: The requirements.txt file had several unpinned dependencies and some outdated pinned dependencies. This could lead to unpredictable builds or the accidental installation of packages with known vulnerabilities. Fix: All dependencies in requirements.txt have been pinned to specific, known-good versions. All packages have been upgraded to their latest secure versions as of the time of the fix. This ensures a reproducible and secure environment.","title":"3.1. Outdated and Unpinned Dependencies (Medium Severity) - FIXED"},{"location":"SECURITY/#32-cicd-pipeline-enforcement-low-severity","text":"Observation: The CI pipeline in .github/workflows/ci.yml is very strong, including bandit for static analysis and trivy for vulnerability scanning. Recommendation: Ensure the pipeline is configured to fail the build if significant vulnerabilities are found. The current trivy configuration ( exit-code: '1' ) does this, which is great. Consider adding a similar flag to the bandit step to fail the build for high-severity findings (e.g., bandit -r . -ll -c bandit.yaml ).","title":"3.2. CI/CD Pipeline Enforcement (Low Severity)"},{"location":"SECURITY/#4-general-security-best-practices","text":"","title":"4. General Security Best Practices"},{"location":"SECURITY/#41-use-of-security-headers","text":"Observation: The application does not appear to be setting modern security headers. Recommendation: Use a library like Flask-Talisman to easily set HTTP security headers such as Content-Security-Policy (CSP) , Strict-Transport-Security (HSTS) , X-Content-Type-Options , and X-Frame-Options . These headers can help mitigate a wide range of attacks, including XSS and clickjacking.","title":"4.1. Use of Security Headers"},{"location":"SECURITY/#42-sensitive-data-in-session","text":"Observation: The Flask session is used to store the user's ID and admin status. Flask's default session is signed but not encrypted. Recommendation: This is generally acceptable for non-sensitive data like a user ID. However, be mindful not to store any highly sensitive information in the session. If you ever need to, consider enabling server-side sessions where the session data is stored in a database or cache (like Redis) and only a session identifier is sent to the client.","title":"4.2. Sensitive Data in Session"}]}