# Requirements for Migrating Pick-a-Ladder to Firebase

## 1. Overview

This document outlines the requirements for refactoring the Pick-a-Ladder web application from its current Flask and PostgreSQL architecture to a serverless backend using Google Firebase services. The primary motivation for this migration is to resolve persistent and complex server environment issues related to Docker networking, container orchestration, and database connectivity.

The goal is to create a more reliable, scalable, and easier-to-manage backend while retaining all existing application functionality. The migration will involve a complete rewrite of the data access, authentication, and file storage layers.

## 2. Core Firebase Services to be Used

The new architecture will be built on the following Firebase services:

*   **Firebase Authentication:** To handle all user identity and authentication tasks (sign-up, login, password reset, email verification).
*   **Cloud Firestore:** A NoSQL document database that will replace PostgreSQL as the primary data store for all application data (users, matches, groups, etc.).
*   **Firebase Storage:** To store all user-generated content, specifically user profile pictures.

## 3. Data Model Migration (PostgreSQL to Firestore)

The existing SQL data models must be migrated to a NoSQL document-based structure in Firestore. The following collections and data structures are proposed. Note that Firestore document IDs will be used as the primary identifier for all resources.

### 3.1. `users` Collection

A root-level collection where each document represents a single user. The document ID should be the `uid` generated by Firebase Authentication.

*   **Document ID:** `auth.uid`
*   **Fields:**
    *   `username`: (String) - Must remain unique.
    *   `email`: (String) - The email used for authentication.
    *   `name`: (String) - The user's full name.
    *   `duprRating`: (Number) - The user's DUPR rating.
    *   `isAdmin`: (Boolean) - `true` if the user has administrative privileges.
    *   `profilePictureUrl`: (String) - URL to the full-size profile picture in Firebase Storage.
    *   `profilePictureThumbnailUrl`: (String) - URL to the thumbnail-size profile picture.
    *   `darkMode`: (Boolean) - User's preference for dark mode.
    *   `createdAt`: (Timestamp) - Server-side timestamp of account creation.

### 3.2. `matches` Collection

A root-level collection for all matches.

*   **Document ID:** Auto-generated by Firestore.
*   **Fields:**
    *   `player1Ref`: (DocumentReference) - A reference to the user document of player 1.
    *   `player2Ref`: (DocumentReference) - A reference to the user document of player 2.
    *   `player1Score`: (Number)
    *   `player2Score`: (Number)
    *   `matchDate`: (Timestamp)

### 3.3. `groups` Collection

A root-level collection for user-created groups.

*   **Document ID:** Auto-generated by Firestore.
*   **Fields:**
    *   `name`: (String)
    *   `description`: (String)
    *   `ownerRef`: (DocumentReference) - A reference to the user document of the group's owner.
    *   `members`: (Array of DocumentReference) - An array containing references to all user documents that are members of the group.

### 3.4. Friends Relationship

The many-to-many friends relationship will be modeled using a sub-collection on each user document. This is a robust way to handle this relationship in Firestore.

*   For a user with ID `userA`, their friends will be stored in a sub-collection at: `/users/userA/friends`.
*   Each document in the `friends` sub-collection represents a friendship. The document ID should be the `uid` of the friend.
*   **Document ID:** `friend.uid`
*   **Fields:**
    *   `status`: (String) - e.g., "pending", "accepted".
    *   `createdAt`: (Timestamp) - When the friend request was initiated.

### 3.5. `settings` Collection

A root-level collection to store global application settings.

*   **Document ID:** The key of the setting (e.g., "enforceEmailVerification").
*   **Fields:**
    *   `value`: (Varies) - The value of the setting (e.g., Boolean `true`).

## 4. Authentication Refactoring

The entire authentication system must be rebuilt using Firebase Authentication.

*   **Registration:** The "Register" page will use the Firebase SDK to create a new user with an email and password. Upon successful creation, a corresponding user document must be created in the `users` collection in Firestore.
*   **Login/Logout:** All login and logout functionality will be handled by the Firebase SDK.
*   **Session Management:** Flask's session management will be replaced. The application will rely on the Firebase ID token, which should be sent from the client on each authenticated request and verified on the server-side by the Flask backend.
*   **Password Reset:** The "Forgot Password" flow will use the built-in Firebase Authentication "send password reset email" functionality.
*   **Email Verification:** The email verification flow will use the built-in Firebase Authentication functionality. The application must check the `email_verified` status from the user's Firebase token.
*   **Initial Admin User:** The application must still handle the "first run" scenario. If there are no documents in the `users` collection with `isAdmin: true`, the application should redirect to the `/install` page to create the first administrative user.

## 5. File Storage Refactoring

All user profile picture functionality must be migrated to Firebase Storage.

*   **Uploads:** When a user uploads a profile picture, the file must be uploaded directly from the client (or via the server) to a private, user-specific path in Firebase Storage (e.g., `/profile-pictures/{user_uid}/original.jpg`).
*   **Security Rules:** Firebase Storage security rules must be implemented to ensure that users can only write to their own storage path.
*   **Thumbnail Generation:** The current implementation generates thumbnails on the server. This should be replaced with a more scalable solution. **Requirement:** Implement a **Firebase Cloud Function** that triggers on file upload to Firebase Storage. This function will automatically generate a thumbnail (e.g., 100x100 pixels) and save it to a different path in the user's storage bucket. The URLs for both the original and the thumbnail must then be updated in the user's document in the `users` collection.

## 6. Application Logic Refactoring

All application code that currently interacts with the PostgreSQL database via SQLAlchemy must be rewritten to use the Firebase Admin SDK for Python.

*   A comprehensive code review must be performed to identify all instances of `db.session` usage.
*   All routes in `auth`, `admin`, `user`, `match`, and `group` blueprints must be refactored.
*   All forms in `forms.py` that rely on database queries for validation must be updated.
*   All utility functions in `utils.py` that perform database operations must be rewritten.

## 7. Environment and Configuration

*   **Firebase Credentials:** The Firebase Admin SDK requires service account credentials. These credentials (a JSON file) must **not** be committed to the repository. They should be stored securely as a GitHub secret and loaded into the production environment during the deployment workflow.
*   **Deployment Workflow:** The `.github/workflows/deploy.yml` file must be updated. The `db` service and the `postgres_data` volume must be removed. The workflow will need a new step to securely load the Firebase service account key into the server environment for the application to use.

## 8. Corner Cases and Considerations

*   **Data Migration:** The current user base is small or non-existent, so a complex data migration script from PostgreSQL to Firebase is not required at this stage. The new system will start fresh.
*   **Error Handling:** All calls to Firebase services must be wrapped in appropriate `try...except` blocks to handle potential API errors gracefully (e.g., permission denied, document not found).
*   **Security Rules:** This is a critical requirement. Write and test comprehensive security rules for both Firestore and Firebase Storage. The default should be to deny all access. Rules should be written to grant access only to authenticated users for their own data. Administrative access should also be handled via security rules where possible.
*   **Uniqueness Constraints:** Firestore does not enforce unique field values (e.g., for `username`). This must be handled by the application logic. When a user registers, the application must first query the `users` collection to ensure the chosen username is not already taken before creating the new user. This must be done in a transaction to avoid race conditions.

## 9. Definition of Done

The migration will be considered complete when all of the following criteria are met:

1.  [ ] All PostgreSQL-related code (`SQLAlchemy`, `psycopg2-binary`) has been removed from the application.
2.  [ ] All user authentication flows (register, login, logout, password reset) are fully functional using Firebase Authentication.
3.  [ ] The initial admin user setup flow is working correctly.
4.  [ ] Users can upload and change their profile pictures, and thumbnails are generated and displayed correctly.
5.  [ ] All "friends" features (sending requests, accepting requests, viewing friends) are fully functional.
6.  [ ] All "groups" features (creating, editing, joining, viewing) are fully functional.
7.  [ ] All "match" features (creating matches, viewing leaderboard) are fully functional.
8.  [ ] All administrative functions are working correctly.
9.  [ ] The deployment workflow is updated and successfully deploys the new Firebase-backed application.
10. [ ] Comprehensive security rules for Firestore and Firebase Storage are implemented and tested.
11. [ ] The application is stable and the original 500 error is resolved.